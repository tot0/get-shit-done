---
phase: 01-commit-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "globToRegex converts glob patterns to working RegExp objects that correctly match file paths"
    - "loadConfig returns pr_branch_base and pr_branch_filter_paths from config.json or defaults"
    - "resolveBaseBranch finds the correct base branch via flag > config > auto-detect priority"
    - "getMergeBase returns the merge-base SHA between base branch and HEAD"
    - "listCommits returns parsed commit objects with hash, subject, and merge detection"
    - "getCommitFiles returns file paths for both regular and merge commits"
    - "classifyCommit categorizes commits as planning, code, or mixed based on filter patterns"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "All helper functions and git adapter functions for commit classification"
      contains: "function globToRegex"
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "Color output utilities"
      contains: "function useColor"
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "Config extension for pr_branch"
      contains: "pr_branch_base"
  key_links:
    - from: "classifyCommit"
      to: "globToRegex"
      via: "filter patterns converted to RegExp and tested against file paths"
      pattern: "filterPatterns\\.some.*\\.test"
    - from: "getCommitFiles"
      to: "execGit"
      via: "diff-tree for regular commits, diff --name-only for merge commits"
      pattern: "execGit.*diff"
    - from: "resolveBaseBranch"
      to: "execGit"
      via: "rev-parse --verify to check branch existence"
      pattern: "rev-parse.*--verify"
---

<objective>
Build the commit classification engine: helper utilities (glob matching, ANSI colors), config extension, and all git adapter functions needed to resolve the base branch, list commits since divergence, get files per commit, and classify each commit as planning-only, code-only, or mixed.

Purpose: These functions are the foundation that Plan 02's `cmdPrBranch()` will orchestrate. Separating engine from presentation keeps each plan focused and within context budget.

Output: `gsd-tools.js` extended with ~8 new functions and config fields, ready for the CLI subcommand in Plan 02.
</objective>

<execution_context>
@/Users/lupickup/.config/Claude/get-shit-done/workflows/execute-plan.md
@/Users/lupickup/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-commit-pipeline/01-RESEARCH.md
@.planning/phases/01-commit-pipeline/01-CONTEXT.md
@get-shit-done/bin/gsd-tools.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add glob matching, ANSI color helpers, and extend loadConfig</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add three groups of code to gsd-tools.js, all in the Helpers section (between the existing helpers and the Commands section):

**1. Glob-to-RegExp conversion** — Add `globToRegex(pattern)` function:
- If pattern ends with `/`, append `**` (directory patterns match all contents)
- Convert `**` followed by `/` to `(?:.*/)?` (match any path segments)
- Convert standalone `**` to `.*`
- Convert `*` to `[^/]*` (match within single path segment)
- Convert `?` to `[^/]`
- Escape regex special chars: `.+^${}()|[]\`
- Wrap in `^` and `$` anchors
- Return a `RegExp` object
- Reference the verified implementation in 01-RESEARCH.md — all 7 test cases pass

**2. ANSI color utilities** — Add above the Commands section:
- `COLORS` constant object with keys: `reset`, `bold`, `dim`, `red`, `green`, `yellow`, `cyan`, `gray` — using `\x1b[Nm` escape codes (see research for exact values)
- `useColor()` function: returns `false` if `process.env.NO_COLOR !== undefined`, `true` if `process.env.FORCE_COLOR !== undefined`, otherwise `process.stdout.isTTY === true`
- `c(color, text)` function: returns `COLORS[color] + text + COLORS.reset` if `useColor()`, otherwise plain `text`

**3. Extend `loadConfig()`** — Add two new fields to the existing `loadConfig()` function:
- Add to `defaults` object: `pr_branch_base: null` and `pr_branch_filter_paths: ['.planning/']`
- Add to the return statement: 
  - `pr_branch_base: get('pr_branch_base', { section: 'pr_branch', field: 'base_branch' }) ?? defaults.pr_branch_base`
  - `pr_branch_filter_paths: get('pr_branch_filter_paths', { section: 'pr_branch', field: 'filter_paths' }) ?? defaults.pr_branch_filter_paths`

Follow existing code style: 2-space indent, semicolons, single quotes, camelCase functions.
  </action>
  <verify>
Run: `node get-shit-done/bin/gsd-tools.js state load --raw` — should still work (no regressions from config changes). Verify output includes existing fields.

Visually confirm the new code is placed correctly in the file:
- `globToRegex` in Helpers section
- COLORS/useColor/c above Commands section  
- loadConfig extended with pr_branch fields
  </verify>
  <done>
- `globToRegex` function exists and handles: directory trailing `/`, `**`, `*`, `?`, regex escaping
- `COLORS` object, `useColor()`, and `c()` function exist with NO_COLOR/FORCE_COLOR/isTTY support
- `loadConfig()` returns `pr_branch_base` (default null) and `pr_branch_filter_paths` (default `['.planning/']`)
- Existing `state load` command still works (no regression)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add git adapter and commit classification functions</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add the following functions to gsd-tools.js, in the Helpers section after the glob/color utilities from Task 1 but before the Commands section. All functions use the existing `execGit(cwd, args)` helper.

**1. `resolveBaseBranch(cwd, config, flagBase)`** — Resolve which branch to use as base:
- Build candidates array in priority order: `flagBase` (if truthy), `config.pr_branch_base` (if truthy), then `'main'`, `'master'`
- Iterate candidates, call `execGit(cwd, ['rev-parse', '--verify', branch])` for each
- Return the first branch where `exitCode === 0`
- Return `null` if none found (caller handles interactive prompt or error)

**2. `getMergeBase(cwd, baseBranch)`** — Find divergence point:
- Call `execGit(cwd, ['merge-base', baseBranch, 'HEAD'])`
- Return `r.stdout` (full SHA) if `exitCode === 0`, else `null`

**3. `listCommits(cwd, mergeBase)`** — List commits in range:
- Call `execGit(cwd, ['log', '--format=%h%x00%s%x00%p', mergeBase + '..HEAD'])`
- If `exitCode !== 0` or `!r.stdout`, return `[]`
- Split by newline, parse each line by NUL (`\0`) separator into `{ hash, subject, isMerge }` objects
- `isMerge` is `true` when the parents field contains a space (multiple parents)
- Return array (newest-first, which is git log's default order — matches LOCKED decision for newest-to-oldest)

**4. `getCommitFiles(cwd, hash, isMerge)`** — Get files touched by a commit (merge-safe):
- CRITICAL: For merge commits (`isMerge === true`), use `execGit(cwd, ['diff', '--name-only', hash + '^1', hash])` — because `diff-tree` returns EMPTY for merge commits (verified pitfall from research)
- For regular commits, use `execGit(cwd, ['diff-tree', '--no-commit-id', '-r', '--name-only', hash])`
- Return `r.stdout.split('\n').filter(Boolean)` if exitCode 0, else `[]`

**5. `classifyCommit(files, filterPatterns)`** — Classify a commit's files:
- `filterPatterns` is an array of RegExp objects (already converted from globs)
- Iterate files, push each to `planningFiles` or `codeFiles` based on whether any filter pattern matches
- Determine type: both arrays non-empty = `'mixed'`, only planning = `'planning'`, otherwise = `'code'`
- Return `{ type, planningFiles, codeFiles }`

**6. `promptForBranch()`** — Interactive fallback (async):
- Add `const readline = require('readline');` at the top of the file with the other requires
- Return a Promise
- Check `process.stdin.isTTY` — if falsy, reject with Error: `'Cannot auto-detect base branch. Use --base <branch> or set pr_branch.base_branch in config.'`
- Create readline interface with `input: process.stdin, output: process.stderr` (stderr keeps stdout clean for piping)
- Question: `'Enter base branch name: '`
- On answer: close interface, trim answer, reject if empty (`'No branch name provided'`), else resolve with trimmed branch name

Follow existing code style. The `readline` require goes at the top with the other requires (line 20-22 area).
  </action>
  <verify>
Run: `node get-shit-done/bin/gsd-tools.js state load --raw` — should still work (no regressions).

Run: `node -e "const m = require('./get-shit-done/bin/gsd-tools.js')"` — if this errors due to main() calling process.exit, that's expected. Check that the require doesn't throw a SyntaxError (no syntax errors in new code). Alternative: `node -c get-shit-done/bin/gsd-tools.js` to syntax-check without executing.
  </verify>
  <done>
- `resolveBaseBranch()` exists and tries flag > config > main > master priority
- `getMergeBase()` exists and returns SHA or null
- `listCommits()` exists, parses NUL-separated format, detects merge commits
- `getCommitFiles()` exists and uses diff-tree for regular commits, diff --name-only for merge commits (CRITICAL merge commit handling)
- `classifyCommit()` exists and returns `{ type, planningFiles, codeFiles }`
- `promptForBranch()` exists, is async, checks isTTY, uses readline
- `readline` is required at the top of the file
- No syntax errors
- Existing commands still work
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `node -c get-shit-done/bin/gsd-tools.js` — syntax check passes
2. `node get-shit-done/bin/gsd-tools.js state load --raw` — existing functionality preserved
3. All new functions exist in the file: globToRegex, useColor, c, resolveBaseBranch, getMergeBase, listCommits, getCommitFiles, classifyCommit, promptForBranch
4. loadConfig returns pr_branch_base and pr_branch_filter_paths
5. readline is required at top of file
</verification>

<success_criteria>
The engine layer is complete: gsd-tools.js contains all helper utilities and git adapter functions needed for commit classification. No CLI wiring yet — that's Plan 02. The file has no syntax errors and existing commands continue to work.
</success_criteria>

<output>
After completion, create `.planning/phases/01-commit-pipeline/01-01-SUMMARY.md`
</output>
