---
phase: 02-branch-builder
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [get-shit-done/bin/gsd-tools.js]
autonomous: true

must_haves:
  truths:
    - "Running `node gsd-tools.js pr-branch` without --dry-run creates a {source}-pr branch with cherry-picked code-only commits"
    - "Running the tool again after adding new source commits cherry-picks only NEW non-planning commits (incremental update)"
    - "Mixed commits are warned about and skipped in the execution summary"
    - "Cherry-pick conflicts cause immediate abort with conflict file report"
    - "Force-push warning appears when PR branch was pushed and source was rebased"
    - "Source branch and working tree are never modified"
    - "Human-readable summary shows commits included, excluded, skipped, and PR branch name"
    - "Raw JSON output includes all execution results"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "buildPatchIdMap, findNewCodeCommits, execution mode in cmdPrBranch, updated CLI router"
      contains: "buildPatchIdMap"
  key_links:
    - from: "cmdPrBranch execution mode"
      to: "createWorktree + cherryPickCommits + removeWorktree"
      via: "try/finally block"
      pattern: "finally.*removeWorktree"
    - from: "findNewCodeCommits"
      to: "buildPatchIdMap"
      via: "patch-id comparison"
      pattern: "patch-id.*stable"
    - from: "CLI router"
      to: "cmdPrBranch"
      via: "removed dryRun override"
      pattern: "case 'pr-branch'"
---

<objective>
Add incremental update detection via patch-id matching, wire the complete execution flow into cmdPrBranch, and update the CLI router to allow non-dry-run mode.

Purpose: This completes Phase 2 by connecting Plan 01's building blocks into the command flow. After this plan, `node gsd-tools.js pr-branch` creates/updates a PR branch, and `--dry-run` previews without modifying anything.

Output: cmdPrBranch gains execution mode with worktree-based cherry-pick, incremental updates, force-push detection, and execution summary. CLI router removes the Phase 1 dry-run override.
</objective>

<execution_context>
@/Users/lupickup/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/lupickup/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-branch-builder/02-RESEARCH.md
@.planning/phases/02-branch-builder/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add patch-id incremental detection functions</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add the following functions after `cherryPickCommits()` (from Plan 01) and before `promptForBranch()`:

1. **`buildPatchIdMap(cwd, commitSHAs)`** — Compute patch-id for each commit SHA, return Map of patchId→sha.
   - `const map = new Map();`
   - For each SHA in `commitSHAs`:
     - `const diff = execGit(cwd, ['diff-tree', '-p', sha]);`
     - If exitCode !== 0 or !stdout → skip (continue)
     - Use `execSync('git patch-id --stable', { input: diff.stdout, cwd, encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] })` wrapped in try/catch
     - Parse output: `const patchId = out.trim().split(' ')[0];`
     - `map.set(patchId, sha);`
   - Return map
   - ~15-20 lines

2. **`findNewCodeCommits(cwd, baseBranch, prBranch, codeCommits)`** — Find code commits not yet on PR branch using patch-id matching. Returns `{ newCommits, needsRebuild }`.
   - Get PR branch commit SHAs: `execGit(cwd, ['rev-list', baseBranch + '..' + prBranch])`, split by newline, filter empty → `prSHAs`
   - If prSHAs is empty → return `{ newCommits: codeCommits, needsRebuild: false }` (fresh PR branch or empty)
   - Build patch-id maps: `const prPatchIds = buildPatchIdMap(cwd, prSHAs);` and `const sourcePatchIds = buildPatchIdMap(cwd, codeCommits.map(c => c.hash));`
   - Filter new commits: for each code commit, compute its patch-id from `sourcePatchIds`, check if `prPatchIds` has it → if NOT in prPatchIds, it's new
   - Detect rebuild scenario: if prSHAs.length > 0 AND zero source patch-ids match any PR patch-ids → `needsRebuild = true` (source was rebased, PR branch is stale)
   - Return `{ newCommits, needsRebuild }`
   - ~25-35 lines

IMPORTANT: `execSync` is already imported at the top of gsd-tools.js (line 23: `const { execSync } = require('child_process');`). Use it directly for the `patch-id --stable` pipe — this is one of the few cases where execGit isn't suitable because we need stdin piping.
  </action>
  <verify>
Run `node get-shit-done/bin/gsd-tools.js --help 2>&1 || true` — file parses without error.
Run `grep -c "function buildPatchIdMap\|function findNewCodeCommits" get-shit-done/bin/gsd-tools.js` — should output 2.
Run `grep "patch-id.*stable" get-shit-done/bin/gsd-tools.js` — should match.
  </verify>
  <done>buildPatchIdMap and findNewCodeCommits functions exist. Patch-id matching enables stateless incremental update detection.</done>
</task>

<task type="auto">
  <name>Task 2: Wire execution mode into cmdPrBranch and update CLI router</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
This task modifies the existing `cmdPrBranch()` function and CLI router. There are three parts:

**Part A: Add execution path to cmdPrBranch()**

After the existing dry-run report code (the `process.stdout.write(lines.join('\n') + '\n');` near line 410), add the execution branch. The existing dry-run code should run when `flags.dryRun` is true. The new execution code runs when `flags.dryRun` is false.

Structure the function with an early return after the dry-run report:
- After the existing report output, add: `if (flags.dryRun) { process.exit(0); }` (or `return;` if the function already exits)

Then add the execution path:

1. **Derive PR branch name:**
   - `const prBranch = getPrBranchName(cwd);`
   - If null → `error('Cannot derive PR branch name: detached HEAD. Checkout a branch first.')`

2. **Filter to code-only commits (oldest first for cherry-pick order):**
   - `const codeCommits = classifiedCommits.filter(c => c.type === 'code').reverse();`
   - (classifiedCommits from Phase 1 are newest-first; reverse for chronological cherry-pick)
   - `const mixedCommits = classifiedCommits.filter(c => c.type === 'mixed');`
   - If `codeCommits.length === 0` → report "No code commits to cherry-pick" with mixed count if any, exit 0

3. **Determine incremental vs fresh:**
   - `const prExists = prBranchExists(cwd, prBranch);`
   - If `prExists`:
     - Call `findNewCodeCommits(cwd, baseBranch, prBranch, codeCommits)` → `{ newCommits, needsRebuild }`
     - If `needsRebuild`:
       - Check `prBranchPushed(cwd, prBranch)` → if pushed, warn: "PR branch was pushed to remote. Source appears rebased — update will require force-push." Then `error()` to abort (BRCH-05). The user should delete the PR branch or pass a `--force` flag (future v2).
       - If not pushed, proceed but log warning: "Source appears rebased. PR branch will be rebuilt."
       - Delete old PR branch: `execGit(cwd, ['branch', '-D', prBranch])` and set `prExists = false` and `commitsToCherry = codeCommits`
     - Else: `commitsToCherry = newCommits`
     - If `commitsToCherry.length === 0` → report "PR branch is up to date. No new commits to cherry-pick.", exit 0
   - If NOT prExists: `commitsToCherry = codeCommits`

4. **Create worktree and cherry-pick (try/finally):**
   ```
   let wtPath;
   try {
     const startPoint = prExists ? null : mergeBase;  // use full mergeBase for fresh branch
     wtPath = createWorktree(cwd, prBranch, startPoint);
     if (!wtPath) error('Failed to create worktree for PR branch');
     
     const result = cherryPickCommits(cwd, wtPath, commitsToCherry);
     
     if (result.failed) {
       // UX-03: Conflict report
       const failLines = [];
       failLines.push(c('red', 'Cherry-pick conflict on commit ' + result.failed.hash));
       failLines.push('  Subject: ' + result.failed.subject);
       if (result.failed.conflictFiles.length > 0) {
         failLines.push('  Conflicting files:');
         for (const f of result.failed.conflictFiles) {
           failLines.push('    - ' + f);
         }
       }
       failLines.push('');
       failLines.push('Successfully cherry-picked ' + result.picked.length + ' commit(s) before conflict.');
       failLines.push('PR branch has been left in its pre-update state.');
       process.stderr.write(failLines.join('\n') + '\n');
       process.exit(1);
     }
   } finally {
     removeWorktree(cwd, wtPath);
   }
   ```

5. **Build execution summary (UX-02):**
   - Use ANSI colors matching the Phase 1 report style
   - Header: `"pr-branch: {prBranch}"` with rule line
   - Mode: `"Created new PR branch"` or `"Incremental update"`
   - Show cherry-picked commits: `"  CODE  {hash} {subject}"` in green for each picked
   - Show skipped mixed: `"⚠ MIX   {hash} {subject}"` in yellow for each mixed commit
   - Show skipped merges if any
   - Show skipped empty if any
   - Summary footer: `"Cherry-picked: {N} · Skipped: {M} mixed · PR branch: {prBranch}"`
   - Next action: if mixed > 0 → "Split mixed commits to include their code changes"

6. **Raw JSON output for execution mode:**
   - If `raw`: output structured JSON with `{ mode: 'execute', prBranch, baseBranch, mergeBase, picked: [...], skippedMixed: [...], skippedMerges: [...], skippedEmpty: [...], failed: null }` via `output()` before the human-readable report

**Part B: Update CLI router**

In the CLI router (around line 900-912), remove the line `flags.dryRun = true;` (line 909) that forces dry-run mode. The `--dry-run` flag should now work as intended: when present, dry-run; when absent, execute.

**Part C: Update JSDoc header**

Update the JSDoc comment at the top of the file (line 18) to reflect the new command behavior:
- Change `pr-branch [--dry-run] [--base b]   Classify commits for PR branch filtering`
- To: `pr-branch [--dry-run] [--base b]   Create/update PR branch (--dry-run to preview)`

Important implementation notes:
- BRCH-02: The source branch is NEVER modified. All cherry-pick operations happen in the worktree.
- INTG-04: Cherry-pick preserves author/date/message by default — no special flags needed.
- Use `process.stdout.write()` for the human-readable execution report (same as Phase 1 dry-run report).
- Use `process.stderr.write()` for error messages that should not interfere with `--raw` output.
- When `needsRebuild` and branch is NOT pushed: delete old PR branch, create fresh. This is safe because unpushed branches can be recreated.
  </action>
  <verify>
Run `node get-shit-done/bin/gsd-tools.js --help 2>&1 || true` — file parses without error, shows updated usage string.
Run `grep "flags.dryRun = true" get-shit-done/bin/gsd-tools.js` — should return NO matches (override removed).
Run `grep "getPrBranchName\|prBranchExists\|findNewCodeCommits\|createWorktree\|removeWorktree\|cherryPickCommits" get-shit-done/bin/gsd-tools.js | grep -v "^function" | head -20` — should show these functions being CALLED within cmdPrBranch.
Run `node get-shit-done/bin/gsd-tools.js pr-branch --dry-run 2>&1 | head -5` — dry-run should still work as before.
  </verify>
  <done>
cmdPrBranch has execution mode: creates/updates PR branch via worktree cherry-pick, handles incremental updates via patch-id, detects force-push scenario, outputs execution summary. CLI router allows non-dry-run mode. `--dry-run` previews, omitting it executes.

All Phase 2 success criteria met:
1. `pr-branch` creates {source}-pr with code-only commits
2. Incremental update cherry-picks only new commits
3. Mixed commits warned and skipped
4. Conflict aborts with report
5. Force-push warning when pushed+rebased
  </done>
</task>

</tasks>

<verification>
Run these checks to verify Phase 2 is complete:

1. `node get-shit-done/bin/gsd-tools.js pr-branch --dry-run` — dry-run still works (backward compatible)
2. `grep -c "function getPrBranchName\|function prBranchExists\|function prBranchPushed\|function createWorktree\|function removeWorktree\|function cherryPickCommits\|function buildPatchIdMap\|function findNewCodeCommits" get-shit-done/bin/gsd-tools.js` — should output 8 (all new functions)
3. `grep "flags.dryRun = true" get-shit-done/bin/gsd-tools.js` — no matches (Phase 1 override removed)
4. `grep "finally" get-shit-done/bin/gsd-tools.js` — should match (try/finally for worktree cleanup)
5. `grep "cherry-pick.*abort" get-shit-done/bin/gsd-tools.js` — should match (conflict handling)
6. `grep "patch-id.*stable" get-shit-done/bin/gsd-tools.js` — should match (incremental detection)
7. `grep "force-push\|force.push\|needsRebuild" get-shit-done/bin/gsd-tools.js` — should match (BRCH-05)
</verification>

<success_criteria>
All Phase 2 requirements are satisfied:
- FILT-02: Cherry-picks code-only commits onto PR branch (cherryPickCommits in worktree)
- FILT-03: Mixed commits detected, warned, skipped (classifiedCommits filter + summary)
- BRCH-01: PR branch name derived automatically (getPrBranchName → {source}-pr)
- BRCH-02: Source branch never modified (all ops in worktree, cleaned up via try/finally)
- BRCH-03: Incremental updates via patch-id matching (buildPatchIdMap + findNewCodeCommits)
- BRCH-05: Force-push warning when PR branch pushed and source rebased (needsRebuild + prBranchPushed)
- UX-02: Clear summary with commits included/excluded/skipped and PR branch name
- UX-03: Conflict aborts immediately with commit hash, subject, and conflicting files
- INTG-04: Cherry-pick preserves author, date, message by default
</success_criteria>

<output>
After completion, create `.planning/phases/02-branch-builder/02-02-SUMMARY.md`
</output>
